let vsSource =
    [
            'precision mediump float;',
            'attribute vec3 vertPositions;',
            'attribute vec3 vertColor;',
            'attribute vec3 a_normal;',
            'varying vec3 fragColor;',
            'varying vec3 v_normal;',
            '',
            'uniform vec3 uColors;',
            'uniform mat4 mWorld;',
            'uniform mat4 mView;',
            'uniform mat4 mProj;',
            'uniform vec3 u_lightWorldPosition;',
            'uniform vec3 u_viewWorldPosition;',
            'varying vec3 v_surfaceToLight;',
            'varying vec3 v_surfaceToView;',
            '',
            'void main()',
            '{',
            '   fragColor = uColors;',
            '   vec3 surfaceWorldPosition = (mWorld * vec4(vertPositions, 1.0)).xyz;',
            '   v_surfaceToLight = normalize(u_lightWorldPosition - surfaceWorldPosition);',
            '   v_normal = mat3(mWorld) * a_normal;',
            '   v_surfaceToView = normalize(u_viewWorldPosition - surfaceWorldPosition);',
            '   gl_Position = mProj * mView * mWorld * vec4(vertPositions, 1.0);',
            '}',
    ].join('\n');

let fsSource =
    [
            'precision mediump float;',
            '',
            'varying vec3 fragColor;',
            'varying vec3 v_normal;',
            'varying vec3 v_surfaceToLight;',
            'varying vec3 v_surfaceToView;',
            '',
            'uniform float blinn;',
            'uniform float u_shininess;',
            'uniform float u_lightPower;',
            'uniform float Ka;',  // Ambient reflection coefficient
            'uniform float Kd;', // Diffuse reflection coefficient
                'uniform float Ks;',   // Specular reflection coefficient
            'uniform vec3 u_lightColor;',

            'uniform vec3 ambientColor;',
            'uniform vec3 specularColor;',
            '',
            'void main()',
            '{',
            'vec3 normal = normalize(v_normal);',
            'vec3 surfaceToLightDirection = normalize(v_surfaceToLight);',
            'vec3 surfaceToViewDirection = normalize(v_surfaceToView);',
            'vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);',
            'vec3 reflectDir = reflect(-surfaceToLightDirection, normal);',
            'float specular = 0.0;',
            'float lambertian = max(dot(normal, surfaceToLightDirection), 0.0);',
            'if (lambertian > 0.0) {',
                    'if(blinn > 0.0)',
            '       specular = pow( max(dot(normal, halfVector), 0.0), u_shininess);',
            ' else ',
            '       specular = pow(max(dot(surfaceToViewDirection, reflectDir), 0.0), u_shininess);',
            '}',

            'gl_FragColor = vec4(Ka * ambientColor + Kd * lambertian * fragColor +Ks * specular * specularColor, 1.0);',
            'gl_FragColor.rgb *=u_lightPower; ',
            '',
            '}',
    ].join('\n');


let vsSourceGouraud  =
    [
        'precision mediump float;',
        'attribute vec3 vertPositions;',
        'attribute vec3 vertColor;',
        'attribute vec3 a_normal;',
        'varying vec3 fragColor;',
        'varying vec3 v_normal;',
        '',
        'uniform vec3 uColors;',
        'uniform mat4 mWorld;',
        'uniform mat4 mView;',
        'uniform mat4 mProj;',
        'uniform vec3 u_lightWorldPosition;',
        'uniform vec3 u_viewWorldPosition;',
        'varying vec3 v_surfaceToLight;',
        'varying vec3 v_surfaceToView;',
        '',
        'void main()',
        '{',
        '   fragColor = uColors;',
        '   vec3 surfaceWorldPosition = (mWorld * vec4(vertPositions, 1.0)).xyz;',
        '   v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;',
        '   v_normal = mat3(mWorld) * a_normal;',
        '   v_surfaceToView = normalize(u_viewWorldPosition - surfaceWorldPosition);',
        '   gl_Position = mProj * mView * mWorld * vec4(vertPositions, 1.0);',
        '}',
    ].join('\n');

let fsSourceGouraud  =
    [
        'precision mediump float;',
        '',
        'varying vec3 fragColor;',
        'varying vec3 v_normal;',
        'varying vec3 v_surfaceToLight;',
        'varying vec3 v_surfaceToView;',
        '',
        'uniform float u_shininess;',
        'uniform float u_lightPower;',
        'uniform float Ka;',  // Ambient reflection coefficient
        'uniform float Kd;', // Diffuse reflection coefficient
        'uniform float Ks;',   // Specular reflection coefficient
        'uniform vec3 u_lightColor;',

        'uniform vec3 ambientColor;',
        'uniform vec3 specularColor;',
        '',
        'void main()',
        '{',
        'vec3 normal = normalize(v_normal);',
        'vec3 surfaceToLightDirection = normalize(v_surfaceToLight);',
        'vec3 surfaceToViewDirection = normalize(v_surfaceToView);',
        'vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);',
        'float specular = 0.0;',
        'float lambertian = max(dot(normal, surfaceToLightDirection), 0.0);',
        'if (lambertian > 0.0) {',
        '       specular = pow(dot(normal, halfVector), u_shininess);',
        '}',
        'vec3 diffuseColor = fragColor;',

        'gl_FragColor = vec4(Ka * ambientColor + Kd * lambertian * diffuseColor +Ks * specular * specularColor, 1.0);',
        'gl_FragColor.rgb *=u_lightPower; ',
        '',
        '}',
    ].join('\n');